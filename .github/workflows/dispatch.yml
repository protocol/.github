# Trigger the execution of copy-workflow.yml, in batches of 256 repositories.
# This workflow is needed since GitHub Actions limits the matrix size to 256 jobs.
# We use one job per repository per batch.

on:
  push:
    branches: [ master, testing ]

env:
  # Number of repositories in a batch.
  # Deployment jobs in the same batch are run sequentially.
  # 256 is the upper limit on the number of matrix jobs.
  # Batching too many targets together can result in
  #  could not create workflow dispatch event: HTTP 422: inputs are too large.
  #  when issueing dispatch_workflow event.
  MAX_REPOS_PER_WORKFLOW: 100
  # Number of seconds to wait before starting to watch workflow status.
  # Unfortunately, the interval on the watch is not configurable.
  # The delay helps us save on GH API requests.
  WORKFLOW_COMPLETION_CHECK_DELAY: 60

jobs:
  matrix:
    name: Batch targets
    runs-on: ubuntu-latest
    outputs:
      batches: ${{ steps.set-matrix.outputs.batches }}
    steps:
      - uses: actions/checkout@v2
      - id: set-matrix
        run: |
          targets=()
          for config in configs/*.json; do
            echo "::group::$config"
            if [[ $GITHUB_REF == refs/heads/testing && $config != configs/testing.json ]]; then
              continue
            fi
            if [[ $GITHUB_REF != refs/heads/testing && $config == configs/testing.json ]]; then
              continue
            fi
            defaults=$(jq -c '.defaults' $config)
            # values defined in the repository object will override the default values
            # e.g. { "files": ["a", "b"] } + { "files": ["c"] } = { "files": ["c"] }
            targets+=($(jq -c ".repositories[] | $defaults + ." $config))
            echo "::endgroup::"
          done
          batches=$(jq -sc '[. | _nwise(${{ env.MAX_REPOS_PER_WORKFLOW }})] | to_entries' <<< "${targets[@]}")
          echo "::set-output name=batches::$batches"
  dispatch:
    needs: [ matrix ]
    name: Dispatch copy workflow(batch ${{ matrix.cfg.key }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # We end up with multiple "dispatch" jobs,
        # one per BATCHES "key" chunk above with a "value" array.
        # For each "dispatch" job, matrix.cfg.value is an array, like:
        #
        #   [
        #     {"target": "repo1", "files": [".github/workflows/go-check.yml"]},
        #     {"target": "repo2", "files": [".github/workflows/go-check.yml", ".github/workflows/go-test.yml"]}
        #   ]
        #
        # The triggered copy-workflow jobs use that final array as their matrix.
        # Since max-parallel here is 1, we'll end up with at most copy-workflow@max-parallel + 1 parallel jobs.
        cfg: ${{ fromJson(needs.matrix.outputs.batches) }}
      max-parallel: 1
    env:
      GITHUB_TOKEN: ${{ secrets.WEB3BOT_GITHUB_TOKEN }}
      WORKFLOW_YML: copy-workflow.yml
      WORKFLOW_REPO: protocol/.github
    steps:
      - id: dispatch
        name: Dispatch workflow
        run: |
          start_date="$(date +%s)"
          # 2 toJson calls are needed to turn the array of targets into a string
          echo '{"targets":${{ toJson(toJson(matrix.cfg.value)) }}}' | jq -c '.' | gh workflow run "${{ env.WORKFLOW_YML }}" --ref "${{ github.ref }}" --repo "${{ env.WORKFLOW_REPO }}" --json
          echo "::set-output name=start_date::$start_date"
      - id: run
        name: Wait for run to start
        run: |
          # checks every 3 seconds until the most recent run's created_at
          # is later than the time this job started
          while sleep 3; do
            run="$(gh api "/repos/${{ env.WORKFLOW_REPO }}/actions/workflows/${{ env.WORKFLOW_YML }}/runs?per_page=1" --jq '.workflow_runs[0]')"
            # nothing to check if no run was returned
            if [[ ! -z "$run" ]]; then
              run_start_date="$(date --date="$(jq -r '.created_at' <<< "$run")" +%s)"
              if [[ "$run_start_date" > "${{ steps.dispatch.outputs.start_date }}" ]]; then
                echo "::set-output name=id::$(jq -r '.id' <<< "$run")"
                break
              fi
            fi
          done
      - name: Wait for run to complete
        run: |
          # it is not expected for the run to finish immediately so we add delay before checking on it
          sleep ${{ env.WORKFLOW_COMPLETION_CHECK_DELAY }}
          # refreshes run status every 3 seconds until completion
          # redirecting the stdout to /dev/null because this call is very chatty
          # interval is not configurable
          gh run watch "${{ steps.run.outputs.id }}" --repo "${{ env.WORKFLOW_REPO }}" > /dev/null
      - id: jobs
        name: Retrieve jobs from the run
        env:
          STEP_NAME: 'Force push web3-bot/sync branch'
        run: |
          targets=()
          page=1
          per_page=100
          while jobs="$(gh api -X GET "/repos/${{ env.WORKFLOW_REPO }}/actions/runs/${{ steps.run.outputs.id }}/jobs" -f page="$page" -f per_page="$per_page")"; do
            # add jobs that successfully executed $STEP_NAME to targets
            targets+=($(jq -r '.jobs[] | select(.steps[] | select(.name == "${{ env.STEP_NAME }}") and select(.conclusion == "success")) | .name' <<< "$jobs" ))
            if (( page * per_page >= $(jq -r '.total_count' <<< "$jobs") )); then
              break
            fi
            (( page+=1 ))
          done
          echo "::set-output name=targets::$(jq -nc '$ARGS.positional' --args ${targets[@]})"
      - name: Create PRs if needed
        env:
          PR_TITLE: 'sync: update CI config files'
          PR_BODY: 'Syncing to commit ${{ github.event.head_commit.url }}.'
          PR_BRANCH: 'web3-bot/sync'
        run: |
          for target in $(jq -r '.[]' <<< ${{ toJson(steps.jobs.outputs.targets) }}); do
            base="$(gh api "/repos/${target}" --jq '.default_branch')"
            # try to create a PR
            if result="$(gh api "/repos/$target/pulls" -f title="${{ env.PR_TITLE }}" -f body="${{ env.PR_BODY }}" -f head="${{ env.PR_BRANCH }}" -f base="$base")"; then
              echo "$result"
              echo "::debug::Successfully created a PR for '$target'"
            else
              echo "$result"
              echo "::error ::Failed to create a PR for '$target'"
            fi
            sleep 3
          done
