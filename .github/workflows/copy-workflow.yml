# This workflow is triggered by the dispatch workflow.

name: Deploy

on:
  workflow_dispatch:
    inputs:
      targets:
        description: "List of repository names to deploy to"
        required: true
      override:
        description: "Defaults override to use for each repository"
        required: false
        default: '{}'

defaults:
  run:
    shell: bash

jobs:
  copy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repository: ${{ fromJSON(github.event.inputs.targets) }}
      max-parallel: 10
    env:
      TARGET_REPO_DIR: "target-repo"
      TEMPLATE_REPO_DIR: "template-repo"
      TEMPLATE_DIR: "templates"
      INITIAL_WORKFLOW_DEPLOYMENT: 0
      GO_VERSION_BUMP: 0
      FILES: ""
      DEFAULTS: |
        {
          "Go": {
            "files": [
              ".github/workflows/go-test.yml",
              ".github/workflows/go-check.yml",
              ".github/workflows/releaser.yml",
              ".github/workflows/release-check.yml",
              ".github/workflows/tagpush.yml"
            ],
            "deploy_versioning": true,
            "deploy_go": true,
            "go": {
              "versions": [
                "1.19.x",
                "1.20.x"
              ]
            }
          },
          "JavaScript": {
            "files": [
              ".github/workflows/js-test-and-release.yml"
            ]
          },
          "TypeScript": {
            "files": [
              ".github/workflows/js-test-and-release.yml"
            ]
          }
    name: ${{ matrix.repository }}
    steps:
    - name: Checkout ${{ matrix.repository }}
      uses: actions/checkout@v3
      with:
        path: ${{ env.TARGET_REPO_DIR }}
        repository: ${{ matrix.repository }}
        token: ${{ secrets.WEB3_BOT_GITHUB_TOKEN }}
        persist-credentials: true
        submodules: recursive
    - name: Checkout template repository
      uses: actions/checkout@v3
      with:
        path: ${{ env.TEMPLATE_REPO_DIR }}
        ref: ${{ github.ref }}
    - id: github
      name: determine GitHub context
      working-directory: ${{ env.TARGET_REPO_DIR }}
      env:
        REPO: ${{ matrix.repository }}
        GITHUB_TOKEN: ${{ secrets.WEB3_BOT_GITHUB_TOKEN }}
      run: |
        eof="EOF$RANDOM"
        default_branch="$(git remote show origin | awk '/HEAD branch/ {print $NF}')"
        protected_branches="$(gh api -X GET "/repos/$REPO/branches" -f protected=true | jq -c 'map(.name)')"
        languages="$(gh api -X GET "/repos/$REPO/languages" | jq -c 'to_entries | sort_by(.value) | reverse | map(.key)')"
        echo "json<<$eof" >> $GITHUB_OUTPUT
        echo '{' >> $GITHUB_OUTPUT
        echo '"default_branch":"'"$default_branch"'",' >> $GITHUB_OUTPUT
        echo '"protected_branches":'"$protected_branches"',' >> $GITHUB_OUTPUT
        echo '"languages":'"$languages" >> $GITHUB_OUTPUT
        echo '}' >> $GITHUB_OUTPUT
        echo "$eof" >> $GITHUB_OUTPUT
    - id: config
      working-directory: ${{ env.TARGET_REPO_DIR }}
      env:
        REPO: ${{ matrix.repository }}
        DEFAULTS: ${{ fromJSON(env.DEFAULTS)[fromJSON(steps.github.outputs.json).languages[0]] || '{}' }}
        OVERRIDE: ${{ github.event.inputs.override || '{}' }}
      run: |
        if [[ -f uci.yml ]]; then
          echo "json=$(jq -c --argjson defaults "$DEFAULTS" --argjson override "$OVERRIDE" '$defaults + . + $override' uci.yml)" >> $GITHUB_OUTPUT
        else
          echo "json=$(jq -c --argjson defaults "$DEFAULTS" --argjson override "$OVERRIDE" -n '$defaults + $override')" >> $GITHUB_OUTPUT
    - name: Check out web3-bot/sync branch
      env:
        DEFAULT_BRANCH: ${{ fromJSON(steps.github.outputs.json).default_branch }}
      # If the branch already exists, check it out; otherwise, create it.
      # Then, try rebasing the web3-bot/sync branch onto the default branch.
      # If that fails, reset the web3-bot/sync branch to the default branch.
      run: |
        git checkout web3-bot/sync || git checkout -B web3-bot/sync
        git rebase "$DEFAULT_BRANCH" || (git rebase --abort && git reset --hard "$DEFAULT_BRANCH")
      working-directory: ${{ env.TARGET_REPO_DIR }}
    - name: git config
      working-directory: ${{ env.TARGET_REPO_DIR }}
      run: |
        git config user.name web3-bot
        git config user.email web3-bot@users.noreply.github.com
    - name: determine files to add
      # By setting the environment variable, it's possible to programmatically add / modify this list.
      # See https://github.com/protocol/.github/blob/38135c75e47839623bf9b2748275d8c6167a8fa8/.github/workflows/copy-workflow.yml#L163-L168 for an example, how we used to make use of this.
      env:
        FILES: |
          ${{ toJSON(fromJSON(steps.config.outputs.json).files) }}
          ${{ toJSON(fromJSON(steps.config.outputs.json).extra_files) }}
      run: echo "FILES=$(jq -nc '[inputs] | add' <<< "$FILES")" >> $GITHUB_ENV
    - name: is initial workflow deployment
      # INITIAL_WORKFLOW_DEPLOYMENT=1 iff none of the files in the target repository exist yet
      run: |
        initial_workflow_deployment=1
        for f in $(jq -r '.[]' <<< "$FILES"); do
          if [[ -f $TARGET_REPO_DIR/$f ]]; then
            initial_workflow_deployment=0
            break
          fi
        done
        echo "INITIAL_WORKFLOW_DEPLOYMENT=$initial_workflow_deployment" >> $GITHUB_ENV
    - name: remove Travis (on initial workflow deployment)
      if: env.INITIAL_WORKFLOW_DEPLOYMENT == 1
      working-directory: ${{ env.TARGET_REPO_DIR }}
      run: |
        if [[ -f .travis.yml ]]; then
          git rm .travis.yml
          git commit -m "disable Travis"
        fi
    - name: remove CircleCI (on initial workflow deployment)
      if: env.INITIAL_WORKFLOW_DEPLOYMENT == 1
      working-directory: ${{ env.TARGET_REPO_DIR }}
      run: |
        if [[ -d .circleci ]]; then
          git rm -r .circleci
          git commit -m "disable CircleCI"
        fi
    - name: remove gx (on initial workflow deployment)
      if: env.INITIAL_WORKFLOW_DEPLOYMENT == 1
      working-directory: ${{ env.TARGET_REPO_DIR }}
      run: |
        if [[ -d .gx ]]; then
          git rm -r .gx
          git commit -m "remove .gx"
        fi
    - name: Run steps specific to go
      if: fromJSON(steps.config.outputs.json).deploy_go
      # use of ${{ env.TEMPATE_REPO_DIR }} is not allowed here
      uses: ./template-repo/.github/actions/copy-workflow-go
    - name: Run steps specific to versioning
      if: fromJSON(steps.config.outputs.json).deploy_versioning
      uses: ./template-repo/.github/actions/copy-workflow-versioning
    - id: add-files
      name: Add files
      env:
        CONTEXT: |
          {
            "config": ${{ toJSON(fromJSON(steps.config.outputs.json)) }},
            "github": ${{ toJSON(fromJSON(steps.github.outputs.json)) }}
          }
      run: |
        commited=false
        for f in $(jq -r '.[]' <<< "$FILES"); do
          echo -e "\nProcessing $f."
          # add DO NOT EDIT header
          tmp=$(mktemp)
          cat $TEMPLATE_REPO_DIR/$TEMPLATE_DIR/header.yml $TEMPLATE_REPO_DIR/$TEMPLATE_DIR/$f > $tmp
          # render template
          ./template-repo/scripts/render-template.sh $tmp $CONTEXT $tmp
          # create commit, if necessary
          commit_msg=""
          if [[ ! -f "$TARGET_REPO_DIR/$f" ]]; then
            echo "First deployment.\n"
            commit_msg="add $f"
          else
            status=$(cmp --silent $TARGET_REPO_DIR/$f $tmp; echo $?)
            if [[ $status -ne 0 ]]; then
              echo "Update needed."
              commit_msg="update $f"
            else
              echo "File identical. Skipping."
              continue
            fi
          fi
          mkdir -p "$TARGET_REPO_DIR/$(dirname $f)"
          mv $tmp $TARGET_REPO_DIR/$f
          pushd $TARGET_REPO_DIR > /dev/null
          git add $f
          git commit -m "$commit_msg"
          commited=true
          popd > /dev/null
        done
        echo "commited=$commited" >> $GITHUB_ENV
    - name: Force push web3-bot/sync branch
      if: steps.add-files.outputs.commited == 'true'
      working-directory: ${{ env.TARGET_REPO_DIR }}
      run: git push origin web3-bot/sync -f
