# This workflow is triggered by the dispatch workflow.

name: Deploy

on:
  workflow_dispatch:
    inputs:
      targets:
        description: "List of repositories to deploy to"
        required: true

jobs:
  copy:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        cfg: ${{ fromJson(github.event.inputs.targets) }}
      max-parallel: 10
    name: ${{ matrix.cfg.target }}
    steps:
    - name: Checkout ${{ matrix.cfg.target }}
      uses: actions/checkout@v3
      with:
        path: target
        repository: ${{ matrix.cfg.target }}
        token: ${{ secrets.WEB3BOT_GITHUB_TOKEN }}
        persist-credentials: true
        submodules: recursive
    - name: Checkout template repository
      uses: actions/checkout@v3
      with:
        path: template
        ref: ${{ matrix.cfg.source_ref || github.ref }}
    - id: default
      name: determine GitHub default branch
      working-directory: target
      run: |
        branch=$(git remote show origin | awk '/HEAD branch/ {print $NF}')
        echo "branch=$branch" >> $GITHUB_OUTPUT
    - name: git config
      working-directory: target
      run: |
        git config user.name web3-bot
        git config user.email web3-bot@users.noreply.github.com
    - id: deployment
      name: is initial workflow deployment
      # initial=true iff none of the files in the target repository exist yet
      env:
        FILES: ${{ toJSON(toJSON(matrix.cfg.files)) }}
      run: |
        initial_workflow_deployment=true
        for f in "$(echo "$FILES" | jq -r '.[]')"; do
          if [[ -f "target/$f" ]]; then
            initial_workflow_deployment=false
            break
          fi
        done <<< "$(echo "$FILES" | jq -r '.[]')"
        echo "initial=$initial_workflow_deployment" >> $GITHUB_OUTPUT
    - name: remove Travis (on initial workflow deployment)
      if: steps.deployment.outputs.initial == true
      working-directory: target
      run: |
        if [[ -f .travis.yml ]]; then
          git rm .travis.yml
          git commit -m "disable Travis"
        fi
    - name: remove CircleCI (on initial workflow deployment)
      if: steps.deployment.outputs.initial == true
      working-directory: target
      run: |
        if [[ -d .circleci ]]; then
          git rm -r .circleci
          git commit -m "disable CircleCI"
        fi
    - name: remove gx (on initial workflow deployment)
      if: steps.deployment.outputs.initial == true
      working-directory: target
      run: |
        if [[ -d .gx ]]; then
          git rm -r .gx
          git commit -m "remove .gx"
        fi
    - name: Run steps specific to go
      if: matrix.cfg.deploy_go
      # use of ${{ env.TEMPATE_REPO_DIR }} is not allowed here
      uses: ./template-repo/.github/actions/copy-workflow-go
    - name: Run steps specific to versioning
      if: matrix.cfg.deploy_versioning
      uses: ./template-repo/.github/actions/copy-workflow-versioning
    - name: Add files
      env:
        FILES: ${{ toJSON(toJSON(matrix.cfg.files)) }}
        DEFAULT_BRANCH: ${{ steps.default.outputs.branch }}
      run: |
        while read f; do
        for f in "$(echo "$FILES" | jq -r '.[]')"; do
          echo -e "\nProcessing $f."
          # add DO NOT EDIT header
          tmp=$(mktemp)
          cat template/templates/header.yml template/templates/$f > $tmp
          # replace $default-branch with this repo's GitHub default branch
          sed -i "s:\$default-branch:$DEFAULT_BRANCH:g" $tmp
          # create commit, if necessary
          commit_msg=""
          if [[ ! -f "target/$f" ]]; then
            echo "First deployment.\n"
            commit_msg="add $f"
          else
            status=$(cmp --silent "target/$f" "$tmp"; echo $?)
            if [[ $status -ne 0 ]]; then
              echo "Update needed."
              commit_msg="update $f"
            else
              echo "File identical. Skipping."
              continue
            fi
          fi
          mkdir -p "target/$(dirname $f)"
          mv "$tmp" "target/$f"
          pushd target > /dev/null
          git add $f
          git commit -m "$commit_msg"
          popd > /dev/null
        done
    - id: branch
      name: Check if we need to update the branch
      working-directory: target
      run: echo "update=$(git rev-list HEAD...origin/$(git rev-parse --abbrev-ref HEAD) --ignore-submodules --count 2> /dev/null || echo true)" >> $GITHUB_OUTPUT
    - name: Force push web3-bot/sync branch
      if: steps.branch.outputs.update == 'true'
      working-directory: target
      run: |
        git checkout -B web3-bot/sync
        git push origin web3-bot/sync -f
